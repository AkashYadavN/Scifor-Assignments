# -*- coding: utf-8 -*-
"""Leetcode Problems.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P2Rbi2iE_GdSCPTLaqGpktCIBPoVxRXo
"""

# Merging of String Alternatively

class Solution:
    def mergeAlternately(self, word1: str, word2: str):
        m = len(word1)
        n = len(word2)
        i = 0
        j = 0
        result = []

        while i < m or j < n:
            if i < m:
                result += word1[i]
                i += 1
            if j < n:
                result += word2[j]
                j += 1

        return "".join(result)

# Find the Difference

class Solution:
    def findTheDifference(self, s: str, t: str):
        char_count_s = {}
        char_count_t = {}

        for char in s:
            char_count_s[char] = char_count_s.get(char, 0) + 1

        for char in t:
            char_count_t[char] = char_count_t.get(char, 0) + 1

        for char, count in char_count_t.items():
            if char_count_s.get(char, 0) != count:
                return char


solution_instance = Solution()


s = "abcd"
t = "abcdef"

ret = solution_instance.findTheDifference(s, t)
print(f"The difference is: {ret}")

# find the index of the first occurence of the string

class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        needle_length = len(needle)
        haystack_length = len(haystack)

        for i in range(haystack_length - needle_length + 1):
            if haystack[i:i + needle_length] == needle:
                return i

        return -1


solution_instance = Solution()

haystack = "hello"
needle = "ll"
result = solution_instance.strStr(haystack, needle)
print(result)

# Valid Anagram

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        char_count_s = {}
        char_count_t = {}

        for char in s:
            char_count_s[char] = char_count_s.get(char, 0) + 1

        for char in t:
            char_count_t[char] = char_count_t.get(char, 0) + 1

        return char_count_s == char_count_t

solution_instance = Solution()

s = "anagram"
t = "nagaram"

result = solution_instance.isAnagram(s, t)
print(result)

# Repeated Substring Pattern

class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        length = len(s)
        for substring_length in range(1, length // 2 + 1):
            if length % substring_length == 0:
                substring = s[:substring_length]
                if substring * (length // substring_length) == s:
                    return True
        return False

# Create an instance of the Solution class
solution_instance = Solution()

s = "abab"
result = solution_instance.repeatedSubstringPattern(s)
print(result)

# Move Zeros

from typing import List

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        non_zero_index = 0


        for i in range(len(nums)):
            if nums[i] != 0:
                nums[non_zero_index], nums[i] = nums[i], nums[non_zero_index]
                non_zero_index += 1


        for i in range(non_zero_index, len(nums)):
            nums[i] = 0


solution_instance = Solution()
nums = [0, 1, 0, 3, 12]
solution_instance.moveZeroes(nums)
print(nums)

# Plus One

from typing import List

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        carry = 1
        result = []

        for i in range(len(digits) - 1, -1, -1):
            current_sum = digits[i] + carry
            result.insert(0, current_sum % 10)
            carry = current_sum // 10

        if carry:
            result.insert(0, carry)

        return result

solution_instance = Solution()

digits = [1, 2, 3]
result = solution_instance.plusOne(digits)
print(result)

# Sign of the product of an array

from typing import List

class Solution:
    def arraySign(self, nums: List[int]) -> int:
        product = 1

        for num in nums:
            product *= num

        if product > 0:
            return 1
        elif product < 0:
            return -1
        else:
            return 0


solution_instance = Solution()
nums = [-1, 2, -3, 4]
result = solution_instance.arraySign(nums)
print(result)

# can make AP from Sequence

class Solution:
    def canMakeArithmeticProgression(self, arr):
        arr.sort()
        common_diff = arr[1] - arr[0]

        for i in range(1, len(arr) - 1):
            if arr[i + 1] - arr[i] != common_diff:
                return False

        return True


solution_instance = Solution()
arr = [3, 5, 1]
result = solution_instance.canMakeArithmeticProgression(arr)
print(result)

# Monotonic Array

class Solution:
    def isMonotonic(self, nums):
        increasing = decreasing = True

        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                decreasing = False
            if nums[i] < nums[i - 1]:
                increasing = False

        return increasing or decreasing


solution_instance = Solution()

nums = [1, 2, 2, 3]
result = solution_instance.isMonotonic(nums)
print(result)

# from Roman to integer

class Solution:
    def romanToInt(self, s: str) -> int:
        roman_dict = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }

        result = 0
        prev_value = 0

        for char in reversed(s):
            value = roman_dict[char]
            if value < prev_value:
                result -= value
            else:
                result += value
            prev_value = value

        return result


solution_instance = Solution()


roman_numeral = "MCMXCIV"
integer_value = solution_instance.romanToInt(roman_numeral)
print(f"The integer value of {roman_numeral} is: {integer_value}")